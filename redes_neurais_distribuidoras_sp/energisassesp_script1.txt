function [Y,Xf,Af] = myNeuralNetworkFunction(X,Xi,~)
%MYNEURALNETWORKFUNCTION neural network simulation function.
%
% Auto-generated by MATLAB, 26-Jun-2022 18:50:48.
%
% [Y,Xf,Af] = myNeuralNetworkFunction(X,Xi,~) takes these arguments:
%
%   X = 2xTS cell, 2 inputs over TS timesteps
%   Each X{1,ts} = 6xQ matrix, input #1 at timestep ts.
%   Each X{2,ts} = 1xQ matrix, input #2 at timestep ts.
%
%   Xi = 2x2 cell 2, initial 2 input delay states.
%   Each Xi{1,ts} = 6xQ matrix, initial states for input #1.
%   Each Xi{2,ts} = 1xQ matrix, initial states for input #2.
%
%   Ai = 2x0 cell 2, initial 2 layer delay states.
%   Each Ai{1,ts} = 10xQ matrix, initial states for layer #1.
%   Each Ai{2,ts} = 1xQ matrix, initial states for layer #2.
%
% and returns:
%   Y = 1xTS cell of 2 outputs over TS timesteps.
%   Each Y{1,ts} = 1xQ matrix, output #1 at timestep ts.
%
%   Xf = 2x2 cell 2, final 2 input delay states.
%   Each Xf{1,ts} = 6xQ matrix, final states for input #1.
%   Each Xf{2,ts} = 1xQ matrix, final states for input #2.
%
%   Af = 2x0 cell 2, final 0 layer delay states.
%   Each Af{1ts} = 10xQ matrix, final states for layer #1.
%   Each Af{2ts} = 1xQ matrix, final states for layer #2.
%
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [3.3;1.1;2.4;3.5;-2.9;4.5];
x1_step1.gain = [0.0588235294117647;0.0549450549450549;0.0523560209424084;0.0522193211488251;0.0451467268623025;0.05249343832021];
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = 256.4549866;
x2_step1.gain = 0.00287772273506343;
x2_step1.ymin = -1;

% Layer 1
b1 = [1.8430976212424152738;-1.946083343463959725;0.429671581046626061;-0.42102713000478969585;-0.28152549869312587516;0.10550396782218171565;-0.601297611013776101;3.4931353721554287972;-1.524719055210868035;1.6988079281644823393];
IW1_1 = [-0.99589086967748874368 1.8929532993705502353 -0.39859726188235083955 1.2788765709513827407 -3.5139753502343702429 -2.9665302886419886441 -0.07633127093483557668 -2.2052336825528344733 3.5444744024158385542 0.29496166881660429437 -1.8349256034209351363 0.74297936921625817863;-0.25593293871712768928 0.023065607403223629956 0.15266098580521086925 0.38779298083721430723 4.5160806728861775383 1.4024832933090765064 1.0926635432650961821 0.64992302570016113883 -2.453841585163093697 -2.1569823098167550945 -0.48666280237922310281 0.49174195502353890141;0.15918357929546195217 0.14409288032655942491 0.092651618718020994914 0.073668005772455719127 -0.18747828660171772519 0.019670057900626602282 -0.19884342893992043577 -0.21330799387216806129 -0.05648174925410689301 -0.091368106322340103542 0.088993259858417078645 -0.11185979729234235558;0.273601887967915125 0.17975355382156055217 -0.28320275498013275373 0.31393182197354813079 0.86213512972470973672 0.10695676626322600522 -0.21366003456294874185 -0.21680978770249478838 0.46130980755348843791 -0.53615578908418604076 -0.72786718201392508476 -0.03353860888719735478;-0.4761759470975071018 -0.77295151424886410219 -0.86952705366264104736 -0.97985879126021668828 -0.66423621012246947259 -0.65772794530297140625 0.45467422436192922452 0.61799603683297499312 0.87826644116607466284 1.0426709403480887151 0.6413591118549657466 0.57903842861729037939;-0.3406254699818194176 -0.32076373051245571366 -0.00084971890374781677488 -0.37795074324804595056 -0.49642950805681546056 -0.16683935594508764177 0.32912708743921431642 0.3699513291991001207 -0.13565090880669491979 0.53376278011655453604 0.48276769786871909229 0.1672264356952003761;-3.574118207169008965 -1.3025200788986714961 -2.2966660574553534602 -0.22371760944265423054 -5.6508390474762952849 1.7764253605976032535 0.35302603239289309656 1.7656369951855996892 2.6260438873102267543 4.8799058117901887854 -1.429730453831822734 1.6619605112309452366;0.63862364196657572801 -1.8753306222074097587 -0.45948822772909336809 -1.4054293635192018908 -4.4085263955332933961 -2.7712807458915968972 -1.4427974482831189551 -0.22345245647123293531 1.2997513745195639068 1.9518164575780918568 3.2813400218327108959 -0.1548455453843316787;-1.1303883155561991192 -0.62635825139873846368 0.40571532794583403669 -0.79516945641432490444 -4.5883895743832701086 -0.69170862179347236687 0.59362639041417930574 0.78755946624354233876 -1.0713111012324767479 2.1489748618334663099 3.873307107025617757 -0.099542008477037147163;2.6041355883721344355 2.3504022810107612074 4.3838802698282703929 2.9122375993163376329 5.6006570531557660075 3.823591700196549148 -2.0537368381699181441 -2.5065646323028589748 -3.4809803787596123037 -3.865475175978531297 -5.0772225827778170171 -3.3256622528251456039];
IW1_2 = [3.1003750587389657944 -6.9185011889161680543;6.9903231205340681242 -4.3214345855891886927;-0.34067000989677981293 0.38035994501431563686;0.53814764128853920244 -1.2603369742378585094;3.3927622490515303433 -3.4944686040185000131;0.035500996736563303346 0.19111185086738000094;-2.4743200700070882014 2.4381320461054429849;1.9080658010340727504 0.59275181079238936643;-2.6022616914045433312 5.7416638183293002839;-11.10632842536749898 8.3157902625019151088];

% Layer 2
b2 = 1.3518723842855835393;
LW2_1 = [-0.050823899234557490256 -0.077288796535761344897 -4.5395349027072704473 -3.2843718789828297844 0.8157968685827995392 -5.193216667611650017 -0.011145689324040072843 0.040117848602614893105 0.32200859756011268598 0.13265538980904717503];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = 0.00287772273506343;
y1_step1.xoffset = 256.4549866;

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(X);
if ~isCellX
    X = {X};
end
if (nargin < 2), error('Initial input states Xi argument needed.'); end

% Dimensions
TS = size(X,2); % timesteps
if ~isempty(X)
    Q = size(X{1},2); % samples/series
elseif ~isempty(Xi)
    Q = size(Xi{1},2);
else
    Q = 0;
end

% Input 1 Delay States
Xd1 = cell(1,3);
for ts=1:2
    Xd1{ts} = mapminmax_apply(Xi{1,ts},x1_step1);
end

% Input 2 Delay States
Xd2 = cell(1,3);
for ts=1:2
    Xd2{ts} = mapminmax_apply(Xi{2,ts},x2_step1);
end

% Allocate Outputs
Y = cell(1,TS);

% Time loop
for ts=1:TS
    
    % Rotating delay state position
    xdts = mod(ts+1,3)+1;
    
    % Input 1
    Xd1{xdts} = mapminmax_apply(X{1,ts},x1_step1);
    
    % Input 2
    Xd2{xdts} = mapminmax_apply(X{2,ts},x2_step1);
    
    % Layer 1
    tapdelay1 = cat(1,Xd1{mod(xdts-[1 2]-1,3)+1});
    tapdelay2 = cat(1,Xd2{mod(xdts-[1 2]-1,3)+1});
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = repmat(b2,1,Q) + LW2_1*a1;
    
    % Output 1
    Y{1,ts} = mapminmax_reverse(a2,y1_step1);
end

% Final Delay States
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
Xf = [Xi(:,xits) X(:,xts)];
Af = cell(2,0);

% Format Output Arguments
if ~isCellX
    Y = cell2mat(Y);
end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
y = bsxfun(@minus,x,settings.xoffset);
y = bsxfun(@times,y,settings.gain);
y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
x = bsxfun(@minus,y,settings.ymin);
x = bsxfun(@rdivide,x,settings.gain);
x = bsxfun(@plus,x,settings.xoffset);
end
